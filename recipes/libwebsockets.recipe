# -*- Mode: Python -*- vi:si:et:sw=4:sts=4:ts=4:syntax=python
#from cerbero.tools.libtool import LibtoolLibrary


class Recipe(recipe.Recipe):
    name = 'libwebsockets'
    version = '2.2.1'
    stype = SourceType.TARBALL
    btype = BuildType.AUTOCMAKE

    #tarball_dirname = 'v%s'%version
    url = 'https://github.com/warmcat/libwebsockets/archive/v%s.tar.gz' % version
    licenses = [License.BSD_like]

    #add_host_build_target = False
    #can_use_configure_cache = False
    #configure_tpl = "./configure --prefix %(prefix)s "\
    #                "--libdir %(libdir)s %(options)s"
    patches = ['libwebsockets/0001-AutoCMake-adaptation.patch']
    deps = ['libuv']
    #
    files_libs = ['websockets_static', 'zlib_internal']
    files_devel = ['include/libwebsockets', 'lib/pkgconfig/libwebsockets.pc']

    def prepare(self):
        self.configure_options += " -DLWS_WITH_SSL=OFF "
        # self.configure_options += " -DLWS_OPENSSL_LIBRARIES=%s/lib/ssl.lib " % self.config.prefix
        # self.configure_options += " -DLWS_OPENSSL_INCLUDE_DIRS=%s/include" % self.config.prefix

        self.configure_options += " -DLWS_WITH_LIBUV=ON "
        self.configure_options += " -DLIBUV_INCLUDE_DIRS=%s/include/libuv " % self.config.prefix
        self.configure_options += " -DLIBUV_LIBRARIES=%s/lib/libuv.lib " % self.config.prefix

        self.configure_options += " -DLWS_WITH_SHARED=OFF "
        # self.configure_options += " -DLWS_WITHOUT_TESTAPPS=ON "
        # self.configure_options += " -DLWS_WITHOUT_TEST_SERVER=ON "
        # self.configure_options += " -DLWS_WITHOUT_TEST_SERVER_EXTPOLL=ON "
        # self.configure_options += " -DLWS_WITHOUT_TEST_PING=ON "
        # self.configure_options += " -DLWS_WITHOUT_TEST_ECHO=ON "
        # self.configure_options += " -DLWS_WITHOUT_TEST_CLIENT=ON "
        # self.configure_options += " -DLWS_WITHOUT_TEST_FRAGGLE=ON "

    #    def prepare(self):
    #        if self.config.target_platform == Platform.WINDOWS:
    #            self.make = 'make -f win32/Makefile.gcc PREFIX=%s- ' % self.config.host
    #            self.make_install = 'make install -f win32/Makefile.gcc '\
    #                                'INCLUDE_PATH=%(prefix)s/include '\
    #                                'LIBRARY_PATH=%(prefix)s/lib ' \
    #                                'BINARY_PATH=%(prefix)s/bin ' % {'prefix':self.config.prefix}
    #            self._remove_steps ([BuildSteps.CONFIGURE])
    #        elif self.config.target_platform == Platform.ANDROID:
    #            if self.config.target_arch == Architecture.X86:
    #                self.configure_options += " --uname=i686-linux-android "
    #            if self.config.target_arch == Architecture.X86_64:
    #                self.configure_options += " --uname=x86_64-linux-android "
    #            else:
    #                self.configure_options += " --uname=arm-linux-androideabi "
    #        elif self.config.target_platform == Platform.LINUX:
    #            if self.config.cross_compiling() and self.config.host:
    #                self.configure_options += " --uname=" + self.config.host
    #
    #    def post_install(self):
    #        libtool_la = LibtoolLibrary('z', 1, 2, 8, self.config.libdir,
    #                self.config.target_platform)
    #        libtool_la.save()
    #        # FIXME This is to workaround a build issue trying to ld to libz.so
    #        if self.config.target_platform == Platform.IOS:
    #            try:
    #                os.symlink(os.path.join (self.config.prefix, 'lib', 'libz.dylib'),
    #                        os.path.join (self.config.prefix, 'lib', 'libz.so'))
    #            except OSError:
    #                pass
    #
